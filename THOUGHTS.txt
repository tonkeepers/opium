1/1/26
INTRODUCTION

This is the first project I am working on, with a focus on learning Linux and gaining a deeper understanding of system administration. The project is designed to explore real-world server and networking concepts.

I aim to document every aspect of the project, explaining the code and the reasoning behind design decisions. The goal is to make the project not only understandable for me but also useful as a learning resource for others.

The project involves creating a messenger that uses NGINX as a proxy server. It is not intended to compete with large-scale messaging platforms like Telegram. Instead, the goal is to create a simple, privacy-focused infrastructure tool for users who value control and security.

MORE SPECIFIC OBJECTIVE

The objective is to create a decentralized messenger with end-to-end encryption (E2E), utilizing Tor (Onion routing) to ensure privacy and anonymity.

The client will be browser-based, ensuring cross-platform compatibility without the need for dedicated mobile or desktop applications.

While the goal is to prioritize security and privacy, it is important to note that no system is completely immune to vulnerabilities. Therefore, the project will be open to continuous improvement, with community feedback and contributions playing a vital role in addressing potential issues.

COMMUNITY CONTRIBUTION

As the project evolves and, if a community forms around it, feedback and contributions will be crucial for further improving security, functionality, and usability. I encourage collaboration to make the system more robust, secure, and user-friendly.


*** DRAFT START ***

My today plans include defining the architecture that I intend to implement. And do some tinkering with Linux processes.

Server architecture:

[MASTER] - Foreman, team leader, boss of the workers.

Main Responsibilities:
1. Worker Creation            - Forks a set number of worker processes at startup to handle incoming tasks concurrently.
2. Status Monitoring          - Continuously monitors the health and status of each worker process, ensuring they are alive and functioning as expected.
3. Restarting Crashed Workers - Automatically detects and restarts any workers that crash or become unresponsive to maintain the system’s availability.
4. Graceful Shutdown          - Ensures that all workers are properly terminated and resources are released when the server shuts down.

[WORKER] - Works independently, its main task is to complete its part of the job as efficiently as possible

Main Responsibilities:
1. Handle Client Connections  - Accepts incoming connections from clients (via sockets) and processes requests as part of its assigned tasks.
2. Execute Assigned Tasks     - Completes a specific portion of the workload efficiently. This could include processing data, handling computation, or communicating with other services.
3. Send Results               - After processing the assigned task, the worker sends the result back to the master process or directly to clients if needed.
4. Error Handling             - Handles local errors within its task scope and reports failures to the master process for further action.

****

The advantages of this separation:

For the [MASTER]:
- Ease of implementation and debugging.
- Minimal probability of the errors.
- Easy management of the entire system.

For the [WORKER]:
- Maximum perfomance.
- Isolation from the other workers.
- Specialization in its task.

***** THE CURRENT STRUCTURE OF THE PROJECT ****
▾ src/
- ▸ core/
- ▸ supervisor/
- ▸ master/
- ▸ worker/
- ▸ os/

1. Core Module: 
- This is where will be placing the independent utilities and abstractions that are not tied directly to the messenger logic. The core will contain tools and helper functions that can be used by the other parts of the system, including memory allocations, string manipulations etc.

2. Supervision Module:
- The supervisor is responsible for managing the overall health and lifecycle of the server components. It`s like an orchestrator that initializes the system and manages the state of the server (master and worker processes)

3. Master Module:
- The master is responsible for creating and supervising the worker processes. It manages their lifecycle, distributes tasks, and ensures that workers are alive and working properly.  

4. Worker Module:
- The worker is the individual process that does the actual work. It`s independent and can be managed by the master process, but it doesn`t have to communicate with anything other than the master.

5. OS Module:
- This OS module is specific to the operating system you are targetting.

